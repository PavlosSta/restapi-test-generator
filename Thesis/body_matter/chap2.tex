\chapter{Αυτόματος Έλεγχος Προγραμματιστικών Διεπαφών Διαδικτύου}

\InitialCharacter{Σ}το κεφάλαιο αυτό παρουσιάζεται το θεωρητικό πλαίσιο και αναλυτικά οι
τεχνολογίες που σχετίζονται με την παρούσια εργασία.
Πιο συγκεκριμένα, περιγράφεται η έννοια του ελέγχου λογισμικού 
καθώς και της αρχιτεκτονικής \en{REST}.

\section{Έλεγχος Λογισμικού}
Σε αντίθεση με τα απτά υλικά που μπορούμε να εποπτεύσουμε και να ελέγξουμε εύκολα και γρήγορα τη λειτουργία τους, καθώς και τις αδυναμίες τους,
με τα προγράμματα η διαδικασία αυτή γίνεται αρκετά σύνθετη.

Υπάρχουν οι εξής τρόποι ελέγχου ενός λογισμικού:
\begin{itemize}
    \item Επιθεώρηση του κώδικα (\en{review}), μέσα από την περιήγηση (\en{walkthrough}) ή την επισκόπησή του (\en{inspection}) \cite{myers1978controlled}
    \item Χρήση εργαλείων στατικής ανάλυσης \cite{wichmann1995industrial}
    \item Δυναμικός έλεγχος
\end{itemize}

Οι πρώτοι δύο τρόποι ανήκουν στην κατηγορία του στατικού ελέγχου.
Η παρούσα εργασία επικεντρώνεται στον δυναμικό έλεγχο που γίνεται με την εκτέλεση του προγράμματος με σκοπό την εύρεση σφαλμάτων \cite{ball1999concept}\cite{myers2004art}.

Ο έλεγχος λογισμικού πλέον θεωρείται αναπόσπαστο τμήμα της βιομηχανίας,
με έρευνες να δείχνουν πως η πλειονότητα των εταιρειών σήμερα χρησιμοποιούν είτε επίσημα ορισμένες διαδικασίες ελέγχου,
είτε γενικές αρχές ορθής λειτουργίας \cite{article2010}.
Όμως άλλη έρευνα δείχνει πως ακόμα και εταιρείες που εξειδικεύονται σε ανάπτυξη λογισμικού δεν έχουν ιδανικές μεθόδους ελέγχου \cite{articleMaz}.
Επομένως είναι ένας τομέας που εξακολουθεί να παραμένει επίκαιρος.

Οποιαδήποτε εφαρμογή σχεδιάζεται και υλοποιείται,
από ένα απλό μαθηματικό εργαλείο μέχρι μία περίπλοκη προγραμματιστική διεπαφή,
είναι πιθανό να περιλαμβάνει λάθη.
Όσο αυξάνεται η πολυπλοκότητα της εφαρμογής, τόσο πιο απαραίτητος είναι ο ενδελεχής και αποτελεσματικός έλεγχός της. 
\subsection{Είδη δυναμικού ελέγχου}
Ως προς τον σκοπό του δυναμικού ελέγχου, μπορούμε να ταξινομήσουμε την πληθώρα μεθόδων και τεχνικών στις εξής κατηγορίες \cite{pan1999software}:
\begin{enumerate}
    \item \underline{Έλεγχος Ορθότητας (\en{Correctness Testing})}
    
    Ο βασικότερος έλεγχος που μπορεί να γίνει σε ένα λογισμικό
    είναι αυτός της ορθότητάς του.
    Έχοντας γνώση της σωστής αλλά και της λανθασμένης συμπεριφοράς μιας εφαρμογής, 
    υπάρχουν δύο βασικοί τρόποι αξιολόγησης: 
    \begin{enumerate}
        \item \underline{\en{Black-box Testing} - Έλεγχος βασισμένος σε δεδομένα εισόδου/εξόδου}
        
        Σε αυτή την περίπτωση η εφαρμογή θεωρείται ένα απομονωμένο σύστημα
        του οποίου η δομή παραμένει άγνωστη.
        Η μόνη δυνατότητα που έχουμε είναι να δίνουμε στο σύστημα συγκεκριμένα δεδομένα στην είσοδό του
        και να αξιολογούμε τα αποτελέσματα στην έξοδό του.

        \item \underline{\en{White-box Testing} - Έλεγχος βασισμένος στη λογική}
        
        Με αυτόν τον τρόπο δε βασιζόμαστε μόνο στις προδιαγραφές της εφαρμογής αλλά γνωρίζουμε πλήρως και την υλοποίησή της.
        Σκοπός είναι να εποπτεύσουμε όλα τα σημεία της εφαρμογής,
        να εντοπίσουμε όλους τους πιθανούς τρόπους εκτέλεσής της 
        και να ελέγξουμε τον καθένα για λογικά λάθη.
    \end{enumerate}

    \item \underline{Έλεγχος Απόδοσης (\en{Performance Testing})}
    
    Ορισμένα προγράμματα ενδεχομένως έχουν συγκεκριμένες απαιτήσεις στην απόδοσή τους.
    Γενικότερα όμως υπάρχουν σιωπηρές απαιτήσεις απόδοσης για κάθε εφαρμογή,
    όπως το να χρειάζονται περιορισμένους πόρους συστήματος για την εκτέλεσή τους και αυτή να ολοκληρώνεται εντός λογικών χρονικών περιθωρίων.
    Επομένως για αυτά είναι χρήσιμος ο έλεγχος των παραμέτρων τους που μπορεί να οδηγήσουν σε συμφόρηση των πόρων του συστήματος.

    Τέτοιες παράμετροι είναι για παράδειγμα το εύρος ζώνης δικτύου, οι κύκλοι ρολογιού της Κεντρικής Μονάδας Επεξεργασίας (\en{CPU}),
    ο χώρος στον δίσκο και η χρήση μνήμης \cite{smith1990performance}.

    Αυτού του είδους ο έλεγχος πραγματοποιείται με ειδικές εφαρμογές αρεικρίνησης (\en{benchmarking}) 
    που προσομοιώνουν τις τυπικές απαιτήσεις του προγράμματος που θέλουμε να αξιολογήσουμε \cite{vokolos1998performance}.

    \item \underline{Έλεγχος Αξιοπιστίας (\en{Reliability Testing})}
    
    Ένα πρόγραμμα θα πρέπει γενικά όταν εκτελείται να μην εμφανίζει απρόσμενη συμπεριφορά.
    Παρότι δεν προσδιορίζεται με ακρίβεια, 
    δεχόμαστε ότι ένα πρόγραμμα είναι αξιόπιστο όταν δεν αποτυγχάνει με αναπάντεχους ή καταστροφικούς τρόπους \cite{hamlet1994foundations}.

    Για να επιβεβαιώσουμε την αξιοπιστία ενός προγράμματος,
    χρησιμοποιούμε μεθόδους \en{stress testing} (προσομοίωση ακραίων συνθηκών λειτουργίας με σκοπό την εύρεση ευάλωτων σημείων) \cite{pradeep2019pragmatic}
    και \en{load testing} (ταυτόχρονη πρόσβαση από πολλούς χρήστες) \cite{pan1999software}.

    \item \underline{Έλεγχος Ασφαλείας (\en{Security Testing})}
    
    Σε αντίθεση με τις προηγούμενες κατηγορίες που σχετίζονται με αυθόρμητα σφάλματα λειτουργίας,
    ο έλεγχος ασφαλείας μελετά περιπτώσεις σκόπιμης εκμετάλλευσης των αδυναμιών μιας εφαρμογής.

    Υπό αυτό το πρίσμα, περιλαμβάνονται όλες οι διαδικασίες που πραγματοποιούνται στις φάσεις ανάπτυξης λογισμικού
    και διασφαλίζουν την προστασία του από κακόβουλες επιθέσεις \cite{potter2004software}.

\end{enumerate}

\subsection{Αυτόματη παραγωγή σεναρίων ελέγχου}

Όσο εξελίσσονται τα προγράμματα που χρησιμοποιούμε στην καθημερινότητά μας, 
τόσο αυξάνεται και η σημασία του αποτελεσματικού ελέγχου τους.
Ευτυχώς παράλληλη εξέλιξη παρατηρείται και στα διαθέσιμα εργαλεία και στις τεχνικές ελέγχου που χρησιμοποιούνται \cite{chauhan2014latest}.

Ένας τρόπος να μειωθεί ο χρόνος και το κόστος της διαδικασίας ελέγχου ενός λογισμικού είναι μέσα από την αυτοματοποίησή της \cite{dustin1999automated}.
Το ιδανικό θα ήταν να υπάρχει αυτόματη και πλήρης εξέταση μιας εφαρμογής αξιοποιώντας μόνο τις προδιαγραφές της,
τις οποίες θα περιγράφαμε με κάποιο κατάλληλο μοντέλο \cite{bertolino2007software}.

Αυτό που συμβαίνει στην πράξη είναι προσπάθειες αυτοματοποίησης κάποιων τμημάτων της διαδικασίας ελέγχου.
Αυτές περιλαμβάνουν για παράδειγμα την παραγωγή συγκεκριμένων σεναρίων που διασφαλίζουν την ορθότητα μιας εφαρμογής 
για ορισμένες περιπτώσεις \cite{sneha2017research}.

\section{Η αρχιτεκτονική \en{REST} (\en{Representational State Transfer})}
Μια διεπαφή προγραμματισμού υπολογιστών \en{(API)} είναι ένα σύνολο από διασυνδέσεις μεταξύ εφαρμογών, συστημάτων και συσκευών.
Ένα πλαίσιο επικοινωνίας δηλαδή μεταξύ τους, αυστηρά καθορισμένο ως προς τη μορφή των μηνυμάτων που επιτρέπεται να ανταλλάσσονται, 
το περιεχόμενο που μπορεί αυτά να έχουν και τον τρόπο που δημιουργούνται και τελικά διακινούνται.

Στην πράξη είναι τμήματα λογισμικού ή υλικού που χρησιμοποιούνται με σκοπό την απλούστευση της διαδικασίας προγραμματισμού,
μέσω της αφαιρετικής παρουσίασης των λειτουργιών ενός συστήματος και της εύκολης αξιοποίησής τους από τους χρήστες \cite{date_relational_1975}.

Το πιο δημοφιλές αρχιτεκτονικό στυλ τέτοιων διεπαφών είναι το \en{REST (Representational State Transfer)},
που ορίστηκε το 2000 από τον \en{Fielding} \cite{fielding_architectural_2000} ως ένα σύνολο περιορισμών και κατευθυντήριων γραμμών σχεδιασμού.
Πιο συγκεκριμένα, για να χαρακτηριστεί ένα σύστημα \en{RESTful}, δηλαδή να είναι τύπου \en{REST}, οφείλει να πληροί τους εξής περιορισμούς:

\begin{enumerate}
    \item \underline{Αρχιτεκτονική Πελάτη-Διακομιστή (\en{Client-Server})}
    
    Διαχωρίζοντας το περιβάλλον του χρήστη από αυτό των δεδομένων, 
    βελτιώνουμε τόσο την φορητότητα του περιβάλλοντος του χρήστη μεταξύ πλατφορμών,  
    όσο και την επεκτασιμότητα, κάτι που αποτελεί ισχυρό πλεονέκτημα για τις απαιτήσεις του Διαδικτύου.

    \item \underline{Έλλειψη Κατάστασης (\en{Statelessness})}
    
    Κάθε αίτημα από τον πελάτη προς τον διακομιστή οφείλει να περιλαμβάνει
    όλες τις απαραίτητες πληροφορίες για την εκτέλεση των διεργασιών.
    Έτσι επιτυγχάνεται ευκολότερη παρακολούθηση των εντολών,
    καλύτερη αξιοπιστία σε περιπτώσεις ανάκτησης δεδομένων και βελτιωμένη επεκτασιμότητα, 
    αφού απλοποιείται η υλοποίηση των επιμέρους συστημάτων.
    Ο συμβιβασμός για όλα αυτά είναι η επαναλαμβανόμενη αποστολή ορισμένων δεδομένων από την πλευρά του χρήστη.

    \item \underline{Δυνατότητα αξιοποίησης κρυφής μνήμης (\en{Cacheability})}
    
    Η προσωρινή αποθήκευση δεδομένων στην κρυφή μνήμη (\en{cache}) 
    από τον χρήστη και τα ενδιάμεσα συστήματα
    βελτιώνει την απόδοση του δικτύου,
    αποφεύγοντας την περιττή λήψη δεδομένων,
    όμως εγκυμονεί κινδύνους κατοχής προηγούμενων εκδόσεων αρχείων,
    σε περίπτωση που αυτά έχουν ενημερωθεί από τον διακομιστή
    αλλά δεν έχουν ληφθεί ανανεωμένα από τον χρήστη.

    \item \underline{Ομοιόμορφη Διεπαφή (\en{Uniform Interface})}
    
    Οι ομοιόμορφες διεπαφές μεταξύ των τμημάτων του συστήματος προσφέρουν απλούστερη αρχιτεκτονική και καλύτερη εποπτεία των αλληλεπιδράσεων.
    Το αρνητικό όμως είναι η μείωση της αποδοτικότητας,
    μιας και η πληροφορία μεταδίδεται τυποποιημένη,
    αγνοώντας τις ιδιαιτερότητες κάθε εφαρμογής.

    \item \underline{Πολυεπίπεδο Σύστημα (\en{Layered System})}
    
    Μεταξύ πελάτη και διακομιστή μπορεί να παρεμβληθεί οποιοδήποτε ενδιάμεσο στάδιο,
    χωρίς να υπάρχει εμφανής επίδραση στην επικοινωνία και χωρίς να απαιτούνται τροποποιήσεις στις υλοποιήσεις των τελικών συστημάτων.

    \item \underline{Κώδικας κατά παραγγελία (\en{Code-On-Demand})}
    
    Ο τελευταίος περιορισμός είναι ο μόνος προαιρετικός και αφορά στη δυνατότητα του χρήστη
    να κατεβάσει και να εκτελέσει τμήματα κώδικα με τη μορφή μικροεφαρμογών.
\end{enumerate}

Τα \en{RESTful Web APIs} είναι προγραμματιστικές διεπαφές που ικανοποιούν τα παραπάνω κριτήρια και λειτουργούν στον Παγκόσμιο Ιστό \cite{jin2018designing}.
Συνεπώς οι διεπαφές αυτού του είδους έχουν τα εξής χαρακτηριστικά \cite{amundsen2013restful}:

\begin{itemize}
    \item Έχουν μία διεύθυνση βάσης (\en{base URL}), όπως \emph{\en{https://www.example.com/api}}
    \item Χρησιμοποιούν τις μεθόδους \en{HTTP}, δηλαδή \en{GET, PUT, POST, DELETE} κ.λπ.
    \item Περιλαμβάνουν στα μηνύματά τους αναγνωριστικό για τη μορφή των δεδομένων που αποστέλλονται, όπως για παράδειγμα '\en{text/html}' ή '\en{application/json}'
\end{itemize}

Η πλειονότητα των εταιρειών πληροφορικής σήμερα χρησιμοποιούν προγραμματιστικές διεπαφές διαδικτύου τύπου \en{REST} για τις υπηρεσίες τους,
όπως για παράδειγμα οι
\en{Google}\footnote{\en{https://developers.google.com/gmail/api/reference/rest}},
\en{Twitter}\footnote{\en{https://developer.twitter.com/en/docs/api-reference-index}} και
\en{Wikipedia}\footnote{\en{https://www.mediawiki.org/wiki/API{:}REST\_API}}.
Η πιο συνηθισμένη χρήση είναι η δυνατότητα που προσφέρουν σε οποιονδήποτε προγραμματιστή επιθυμεί να αλληλεπιδράσει με τις εφαρμογές τους
μέσω των διεπαφών τους.

Σε αυτή την περίπτωση δημιουργούν μια σειρά από τελικά σημεία,
δηλαδή σημεία με τα οποία μπορεί κάποιος να αλληλεπιδράσει με τη διεπαφή.
Αυτά έχουν τη μορφή ξεχωριστών διευθύνσεων που επεκτείνουν τη διεύθυνση βάσης,
όπως για παράδειγμα \emph{\en{https://www.example.com/api/users/}},
και προσφέρουν λειτουργίες που πραγματοποιούνται με την αποστολή και λήψη \en{HTTP} μηνυμάτων από και προς την ίδια διεύθυνση \cite{masse_rest_2012}.